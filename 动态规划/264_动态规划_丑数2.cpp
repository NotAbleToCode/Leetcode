// 编写一个程序，找出第 n 个丑数。

// 丑数就是只包含质因数 2, 3, 5 的正整数。

// 示例:

// 输入: n = 10
// 输出: 12
// 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
// 说明:  

// 1 是丑数。
// n 不超过1690。

// 假设已经有前k个丑数组成的数组
// 那么，如何从该数组中得到第k+1个丑数？
// 第k+1个丑数，肯定是该数组的所有元素，乘以2或者3或者5所得到的最小值。
// 遍历一遍？这样时间复杂度O(n^2)
// 可以优化：
// 创建三个指针f1,f2和f3，分别表示数组的某个下标
// 应该保证，f1指向的值和2相乘得到的，是不在数组中的，且数组中所有元素和2相乘，能得到的最小的丑数
// f2,f3，类似。
// 这样每一步，我们只需要将2和f1指向的值相乘，3和f2指向的值相乘，5和f3指向的值相乘，得到的值取最小即可
// 如果f1,f2,f3的初始化和更新规则为O(n)，那么整个算法的时间复杂度就是O(n)的

// f1,f2,f3的初始化和更新规则
// 数组记为s
// 一开始，初始化s[0]=1，f1=f2=f3=0
// 令a=s[f1]*2,b=s[f2]*3,c=f[f3]*5
// 取d=min(a,b,c)
// s.append(d)
// 若d和a相等，则f1++
// 若d和b相等,f2++
// 若d和c相等,f3++

// 这种指针法对其余质因数组成的第n个数的求解也同样适用
#include<iostream>
#include<vector>
using namespace std;

int nthUglyNumber(int n) {
    int f1=0;
    int f2=0;
    int f3=0;
    int a,b,c,d;
    vector<int> f(n);
    f[0]=1;
    for(int i=1;i<n;i++){
        a = 2*f[f1];
        b = 3*f[f2];
        c = 5*f[f3];
        d = min(a,min(b,c));
        f[i] = d;
        if(d==a){
            f1++;
        }
        if(d==b){
            f2++;
        }
        if(d==c){
            f3++;
        }
    }
    return f[n-1];
}

int main(){
    cout<<nthUglyNumber(10)<<endl;
}


